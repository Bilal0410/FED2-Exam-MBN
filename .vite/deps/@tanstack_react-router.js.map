{
  "version": 3,
  "sources": ["../../node_modules/@tanstack/history/src/index.ts", "../../node_modules/tiny-invariant/dist/esm/tiny-invariant.js", "../../node_modules/tiny-warning/dist/tiny-warning.esm.js", "../../node_modules/@tanstack/react-router/src/CatchBoundary.tsx", "../../node_modules/@tanstack/react-router/src/utils.ts", "../../node_modules/@tanstack/react-router/src/path.ts", "../../node_modules/@tanstack/react-router/src/redirects.ts", "../../node_modules/@tanstack/react-router/src/qss.ts", "../../node_modules/@tanstack/react-router/src/searchParams.ts", "../../node_modules/@tanstack/react-router/src/router.ts", "../../node_modules/@tanstack/react-router/src/RouterProvider.tsx", "../../node_modules/@tanstack/react-router/src/Matches.tsx", "../../node_modules/@tanstack/react-router/src/useParams.tsx", "../../node_modules/@tanstack/react-router/src/useSearch.tsx", "../../node_modules/@tanstack/react-router/src/route.ts", "../../node_modules/@tanstack/react-router/src/fileRoute.ts", "../../node_modules/@tanstack/react-router/src/lazyRouteComponent.tsx", "../../node_modules/@tanstack/react-router/src/link.tsx", "../../node_modules/@tanstack/react-router/src/scroll-restoration.tsx", "../../node_modules/@tanstack/react-router/src/useBlocker.tsx", "../../node_modules/@tanstack/react-router/src/useNavigate.tsx"],
  "sourcesContent": ["// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: HistoryLocation\n  subscribe: (cb: () => void) => () => void\n  push: (path: string, state?: any) => void\n  replace: (path: string, state?: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blockerFn: BlockerFn) => () => void\n  flush: () => void\n  destroy: () => void\n  notify: () => void\n}\n\nexport interface HistoryLocation extends ParsedPath {\n  state: HistoryState\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface HistoryState {\n  key: string\n}\n\ntype BlockerFn = (retry: () => void, cancel: () => void) => void\n\nconst pushStateEvent = 'pushstate'\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nfunction createHistory(opts: {\n  getLocation: () => HistoryLocation\n  pushState: (path: string, state: any, onUpdate: () => void) => void\n  replaceState: (path: string, state: any, onUpdate: () => void) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n  flush?: () => void\n  destroy?: () => void\n}): RouterHistory {\n  let location = opts.getLocation()\n  let subscribers = new Set<() => void>()\n  let blockers: BlockerFn[] = []\n  let queue: (() => void)[] = []\n\n  const onUpdate = () => {\n    location = opts.getLocation()\n    subscribers.forEach((subscriber) => subscriber())\n  }\n\n  const tryUnblock = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryUnblock, () => {\n        blockers = []\n        stopBlocking()\n      })\n      return\n    }\n\n    while (queue.length) {\n      queue.shift()?.()\n    }\n  }\n\n  const queueTask = (task: () => void) => {\n    queue.push(task)\n    tryUnblock()\n  }\n\n  return {\n    get location() {\n      return location\n    },\n    subscribe: (cb: () => void) => {\n      subscribers.add(cb)\n\n      return () => {\n        subscribers.delete(cb)\n      }\n    },\n    push: (path: string, state: any) => {\n      state = assignKey(state)\n      queueTask(() => {\n        opts.pushState(path, state, onUpdate)\n      })\n    },\n    replace: (path: string, state: any) => {\n      state = assignKey(state)\n      queueTask(() => {\n        opts.replaceState(path, state, onUpdate)\n      })\n    },\n    go: (index) => {\n      queueTask(() => {\n        opts.go(index)\n      })\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back()\n      })\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (cb) => {\n      blockers.push(cb)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== cb)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify: onUpdate,\n  }\n}\n\nfunction assignKey(state: HistoryState) {\n  if (!state) {\n    state = {} as HistoryState\n  }\n  return {\n    ...state,\n    key: createRandomKey(),\n  }\n}\n\n/**\n * Creates a history object that can be used to interact with the browser's\n * navigation. This is a lightweight API wrapping the browser's native methods.\n * It is designed to work with TanStack Router, but could be used as a standalone API as well.\n * IMPORTANT: This API implements history throttling via a microtask to prevent\n * excessive calls to the history API. In some browsers, calling history.pushState or\n * history.replaceState in quick succession can cause the browser to ignore subsequent\n * calls. This API smooths out those differences and ensures that your application\n * state will *eventually* match the browser state. In most cases, this is not a problem,\n * but if you need to ensure that the browser state is up to date, you can use the\n * `history.flush` method to immediately flush all pending state changes to the browser URL.\n * @param opts\n * @param opts.getHref A function that returns the current href (path + search + hash)\n * @param opts.createHref A function that takes a path and returns a href (path + search + hash)\n * @returns A history instance\n */\nexport function createBrowserHistory(opts?: {\n  getHref?: () => string\n  createHref?: (path: string) => string\n}): RouterHistory {\n  const getHref =\n    opts?.getHref ??\n    (() =>\n      `${window.location.pathname}${window.location.search}${window.location.hash}`)\n\n  const createHref = opts?.createHref ?? ((path) => path)\n\n  let currentLocation = parseLocation(getHref(), window.history.state)\n\n  const getLocation = () => currentLocation\n\n  let next:\n    | undefined\n    | {\n        // This is the latest location that we were attempting to push/replace\n        href: string\n        // This is the latest state that we were attempting to push/replace\n        state: any\n        // This is the latest type that we were attempting to push/replace\n        isPush: boolean\n      }\n\n  // Because we are proactively updating the location\n  // in memory before actually updating the browser history,\n  // we need to track when we are doing this so we don't\n  // notify subscribers twice on the last update.\n  let tracking = true\n\n  // We need to track the current scheduled update to prevent\n  // multiple updates from being scheduled at the same time.\n  let scheduled: Promise<void> | undefined\n\n  // This function is a wrapper to prevent any of the callback's\n  // side effects from causing a subscriber notification\n  const untrack = (fn: () => void) => {\n    tracking = false\n    fn()\n    tracking = true\n  }\n\n  // This function flushes the next update to the browser history\n  const flush = () => {\n    // Do not notify subscribers about this push/replace call\n    untrack(() => {\n      if (!next) return\n      window.history[next.isPush ? 'pushState' : 'replaceState'](\n        next.state,\n        '',\n        next.href,\n      )\n      // Reset the nextIsPush flag and clear the scheduled update\n      next = undefined\n      scheduled = undefined\n    })\n  }\n\n  // This function queues up a call to update the browser history\n  const queueHistoryAction = (\n    type: 'push' | 'replace',\n    path: string,\n    state: any,\n    onUpdate: () => void,\n  ) => {\n    const href = createHref(path)\n\n    // Update the location in memory\n    currentLocation = parseLocation(href, state)\n\n    // Keep track of the next location we need to flush to the URL\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === 'push',\n    }\n    // Notify subscribers\n    onUpdate()\n\n    if (!scheduled) {\n      // Schedule an update to the browser history\n      scheduled = Promise.resolve().then(() => flush())\n    }\n  }\n\n  const onPushPop = () => {\n    currentLocation = parseLocation(getHref(), window.history.state)\n    history.notify()\n  }\n\n  var originalPushState = window.history.pushState\n  var originalReplaceState = window.history.replaceState\n\n  const history = createHistory({\n    getLocation,\n    pushState: (path, state, onUpdate) =>\n      queueHistoryAction('push', path, state, onUpdate),\n    replaceState: (path, state, onUpdate) =>\n      queueHistoryAction('replace', path, state, onUpdate),\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: (n) => window.history.go(n),\n    createHref: (path) => createHref(path),\n    flush,\n    destroy: () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener(pushStateEvent, onPushPop)\n      window.removeEventListener(popStateEvent, onPushPop)\n    },\n  })\n\n  window.addEventListener(pushStateEvent, onPushPop)\n  window.addEventListener(popStateEvent, onPushPop)\n\n  window.history.pushState = function () {\n    let res = originalPushState.apply(window.history, arguments as any)\n    if (tracking) history.notify()\n    return res\n  }\n\n  window.history.replaceState = function () {\n    let res = originalReplaceState.apply(window.history, arguments as any)\n    if (tracking) history.notify()\n    return res\n  }\n\n  return history\n}\n\nexport function createHashHistory(): RouterHistory {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: (path) => `#${path}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {\n    key: createRandomKey(),\n  } as HistoryState\n\n  const getLocation = () => parseLocation(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    pushState: (path, state) => {\n      currentState = state\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = state\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => window.history.go(n),\n    createHref: (path) => path,\n  })\n}\n\nfunction parseLocation(href: string, state: HistoryState): HistoryLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n        ? searchIndex\n        : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search:\n      searchIndex > -1\n        ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex)\n        : '',\n    state: state || {},\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n", "var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n", "var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n", "import * as React from 'react'\n\nexport function CatchBoundary(props: {\n  resetKey: string\n  children: any\n  errorComponent?: any\n  onCatch: (error: any) => void\n}) {\n  const errorComponent = props.errorComponent ?? ErrorComponent\n\n  return (\n    <CatchBoundaryImpl\n      resetKey={props.resetKey}\n      onCatch={props.onCatch}\n      children={({ error }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n          })\n        }\n\n        return props.children\n      }}\n    />\n  )\n}\n\nexport class CatchBoundaryImpl extends React.Component<{\n  resetKey: string\n  children: (props: { error: any; reset: () => void }) => any\n  onCatch?: (error: any) => void\n}> {\n  state = { error: null } as any\n  static getDerivedStateFromError(error: any) {\n    return { error }\n  }\n  componentDidUpdate(\n    prevProps: Readonly<{\n      resetKey: string\n      children: (props: { error: any; reset: () => void }) => any\n      onCatch?: ((error: any, info: any) => void) | undefined\n    }>,\n    prevState: any,\n  ): void {\n    if (prevState.error && prevProps.resetKey !== this.props.resetKey) {\n      this.setState({ error: null })\n    }\n  }\n  componentDidCatch(error: any) {\n    console.error(error)\n    this.props.onCatch?.(error)\n  }\n  render() {\n    return this.props.children(this.state)\n  }\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production')\n\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>\n        <strong style={{ fontSize: '1rem' }}>Something went wrong!</strong>\n        <button\n          style={{\n            appearance: 'none',\n            fontSize: '.6em',\n            border: '1px solid currentColor',\n            padding: '.1rem .2rem',\n            fontWeight: 'bold',\n            borderRadius: '.25rem',\n          }}\n          onClick={() => setShow((d) => !d)}\n        >\n          {show ? 'Hide Error' : 'Show Error'}\n        </button>\n      </div>\n      <div style={{ height: '.25rem' }} />\n      {show ? (\n        <div>\n          <pre\n            style={{\n              fontSize: '.7em',\n              border: '1px solid red',\n              borderRadius: '.25rem',\n              padding: '.3rem',\n              color: 'red',\n              overflow: 'auto',\n            }}\n          >\n            {error.message ? <code>{error.message}</code> : null}\n          </pre>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n", "import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { RouteMatch } from './RouterProvider'\nimport { AnyRoute } from './route'\nimport { ParseRoute, RouteIds, RoutesById, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N = T> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\n// export type Expand<T> = T\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\n// type Compute<T> = { [K in keyof T]: T[K] } | never\n\n// type AllKeys<T> = T extends any ? keyof T : never\n\n// export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n//   {\n//     [K in Keys]: T[Keys]\n//   } & {\n//     [K in AllKeys<T>]?: T extends any\n//       ? K extends keyof T\n//         ? T[K]\n//         : never\n//       : never\n//   }\n// >\n\nexport type Assign<Left, Right> = Omit<Left, keyof Right> & Right\n\nexport type AssignAll<T extends any[]> = T extends [infer Left, ...infer Right]\n  ? Right extends any[]\n    ? Assign<Left, AssignAll<Right>>\n    : Left\n  : {}\n\n// // Sample types to merge\n// type TypeA = {\n//   shared: string\n//   onlyInA: string\n//   nested: {\n//     shared: string\n//     aProp: string\n//   }\n//   array: string[]\n// }\n\n// type TypeB = {\n//   shared: number\n//   onlyInB: number\n//   nested: {\n//     shared: number\n//     bProp: number\n//   }\n//   array: number[]\n// }\n\n// type TypeC = {\n//   shared: boolean\n//   onlyInC: boolean\n//   nested: {\n//     shared: boolean\n//     cProp: boolean\n//   }\n//   array: boolean[]\n// }\n\n// type Test = Expand<Assign<TypeA, TypeB>>\n\n// // Using DeepMerge to merge TypeA and TypeB\n// type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type NonNullableUpdater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\n//\n\nexport const isServer = typeof document === 'undefined'\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult> | NonNullableUpdater<TResult>,\n  previous: TResult,\n): TResult {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return !(\n      a.length !== b.length ||\n      a.some((item, index) => !partialDeepEqual(item, b[index]))\n    )\n  }\n\n  return false\n}\n\nexport function useStableCallback<T extends (...args: any[]) => any>(fn: T): T {\n  const fnRef = React.useRef(fn)\n  fnRef.current = fn\n\n  const ref = React.useRef((...args: any[]) => fnRef.current(...args))\n  return ref.current as T\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nexport type StrictOrFrom<TFrom> =\n  | {\n      from: TFrom\n      strict?: true\n    }\n  | {\n      from?: never\n      strict: false\n    }\n\nexport type RouteFromIdOrRoute<\n  T,\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n> = T extends ParseRoute<TRouteTree>\n  ? T\n  : T extends RouteIds<TRouteTree>\n  ? RoutesById<TRouteTree>[T]\n  : T extends string\n  ? RouteIds<TRouteTree>\n  : never\n\nexport function useRouteContext<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'],\n  TSelected = TRouteContext,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TRouteContext) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) =>\n      opts?.select\n        ? opts.select(match.context as TRouteContext)\n        : match.context,\n  })\n}\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n", "import { MatchLocation } from './RouterProvider'\nimport { AnyPathParams } from './route'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcards: boolean = false,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params[segment.value]\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n", "import { NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\n// Detect if we're in the DOM\n\nexport type AnyRedirect = Redirect<any, any, any>\n\nexport type Redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  code?: number\n}\n\nexport function redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n>(opts: Redirect<TRouteTree, TFrom, TTo>): Redirect<TRouteTree, TFrom, TTo> {\n  ;(opts as any).isRedirect = true\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n", "// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n", "import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else {\n          search[key] = stringifyValue(val)\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n", "import { RouterHistory } from '@tanstack/history'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  AnyPathParams,\n  RouteMask,\n} from './route'\nimport { FullSearchSchema } from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { PickAsRequired, Updater, NonNullableUpdater } from './utils'\nimport {\n  ErrorRouteComponent,\n  PendingRouteComponent,\n  RouteComponent,\n} from './route'\nimport { RouteMatch } from './RouterProvider'\nimport { ParsedLocation } from './location'\nimport { LocationState } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport { RouterContext } from './RouterProvider'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n    __TSR_ROUTER_CONTEXT__?: React.Context<RouterContext<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<AnyRoute, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent<AnySearchSchema, AnyPathParams, AnyContext>\n  defaultErrorComponent?: ErrorRouteComponent<\n    AnySearchSchema,\n    AnyPathParams,\n    AnyContext\n  >\n  defaultPendingComponent?: PendingRouteComponent<\n    AnySearchSchema,\n    AnyPathParams,\n    AnyContext\n  >\n  defaultMaxAge?: number\n  defaultGcMaxAge?: number\n  defaultPreloadMaxAge?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  context?: TRouteTree['types']['routerContext']\n  // dehydrate?: () => TDehydrated\n  // hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<LocationState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<LocationState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'fetchedAt' | 'invalid' | 'id' | 'status' | 'updatedAt'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  options: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  routeTree: TRouteTree\n  // dehydratedData?: TDehydrated\n  // resetNextScroll = false\n  // tempLocationKey = `${Math.round(Math.random() * 10000000)}`\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n    }\n\n    this.routeTree = this.options.routeTree as TRouteTree\n  }\n\n  subscribers = new Set<RouterListener<RouterEvent>>()\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  // dehydrate = (): DehydratedRouter => {\n  //   return {\n  //     state: {\n  //       dehydratedMatches: state.matches.map((d) =>\n  //         pick(d, ['fetchedAt', 'invalid', 'id', 'status', 'updatedAt']),\n  //       ),\n  //     },\n  //   }\n  // }\n\n  // hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n  //   let _ctx = __do_not_use_server_ctx\n  //   // Client hydrates from window\n  //   if (typeof document !== 'undefined') {\n  //     _ctx = window.__TSR_DEHYDRATED__\n  //   }\n\n  //   invariant(\n  //     _ctx,\n  //     'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n  //   )\n\n  //   const ctx = _ctx\n  //   this.dehydratedData = ctx.payload as any\n  //   this.options.hydrate?.(ctx.payload as any)\n  //   const dehydratedState = ctx.router.state\n\n  //   let matches = this.matchRoutes(\n  //     state.location.pathname,\n  //     state.location.search,\n  //   ).map((match) => {\n  //     const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n  //       (d) => d.id === match.id,\n  //     )\n\n  //     invariant(\n  //       dehydratedMatch,\n  //       `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n  //     )\n\n  //     if (dehydratedMatch) {\n  //       return {\n  //         ...match,\n  //         ...dehydratedMatch,\n  //       }\n  //     }\n  //     return match\n  //   })\n\n  //   this.setState((s) => {\n  //     return {\n  //       ...s,\n  //       matches: dehydratedState.dehydratedMatches as any,\n  //     }\n  //   })\n  // }\n\n  // TODO:\n  // injectedHtml: (string | (() => Promise<string> | string))[] = []\n\n  // TODO:\n  // injectHtml = async (html: string | (() => Promise<string> | string)) => {\n  //   this.injectedHtml.push(html)\n  // }\n\n  // TODO:\n  // dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n  //   if (typeof document === 'undefined') {\n  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n  //     this.injectHtml(async () => {\n  //       const id = `__TSR_DEHYDRATED__${strKey}`\n  //       const data =\n  //         typeof getData === 'function' ? await (getData as any)() : getData\n  //       return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n  //         strKey,\n  //       )}\"] = ${JSON.stringify(data)}\n  //       ;(() => {\n  //         var el = document.getElementById('${id}')\n  //         el.parentElement.removeChild(el)\n  //       })()\n  //       </script>`\n  //     })\n\n  //     return () => this.hydrateData<T>(key)\n  //   }\n\n  //   return () => undefined\n  // }\n\n  // hydrateData = <T = unknown>(key: any) => {\n  //   if (typeof document !== 'undefined') {\n  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n  //     return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n  //   }\n\n  //   return undefined\n  // }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n\n  // setRouteMatch = (\n  //   id: string,\n  //   pending: boolean,\n  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,\n  // ) => {\n  //   const key = pending ? 'pendingMatches' : 'matches'\n\n  //   this.setState((prev) => {\n  //     return {\n  //       ...prev,\n  //       [key]: prev[key].map((d) => {\n  //         if (d.id === id) {\n  //           return functionalUpdate(updater, d)\n  //         }\n\n  //         return d\n  //       }),\n  //     }\n  //   })\n  // }\n\n  // setPendingRouteMatch = (\n  //   id: string,\n  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,\n  // ) => {\n  //   this.setRouteMatch(id, true, updater)\n  // }\n}\n\nfunction escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (...args: Parameters<T[TKey]>): Promise<ReturnType<T[TKey]>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n", "import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n} from '@tanstack/history'\nimport * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Matches } from './Matches'\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ResolveRelativePath,\n  ToOptions,\n} from './link'\nimport { ParsedLocation } from './location'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { isRedirect } from './redirects'\nimport { AnyPathParams, AnyRoute, AnySearchSchema, Route } from './route'\nimport {\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteIds,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport {\n  BuildNextOptions,\n  DehydratedRouteMatch,\n  RegisteredRouter,\n  Router,\n  RouterOptions,\n  RouterState,\n  componentTypes,\n} from './router'\nimport {\n  NoInfer,\n  PickAsRequired,\n  functionalUpdate,\n  last,\n  partialDeepEqual,\n  pick,\n  replaceEqualDeep,\n  useStableCallback,\n} from './utils'\nimport { MatchRouteOptions } from './Matches'\n\nexport interface CommitLocationOptions {\n  replace?: boolean\n  resetScroll?: boolean\n  startTransition?: boolean\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport type BuildLinkFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n>(\n  dest: LinkOptions<TRouteTree, TFrom, TTo>,\n) => LinkInfo\n\nexport type NavigateFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => Promise<void>\n\nexport type MatchRouteFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<TRouteTree, TFrom, TTo>,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type LoadFn = (opts?: {\n  next?: ParsedLocation\n  throwOnError?: boolean\n  __dehydratedMatches?: DehydratedRouteMatch[]\n}) => Promise<void>\n\nexport type BuildLocationFn<TRouteTree extends AnyRoute> = (\n  opts: BuildNextOptions,\n) => ParsedLocation\n\nexport type RouterContext<\n  TRouteTree extends AnyRoute,\n  // TDehydrated extends Record<string, any>,\n> = {\n  buildLink: BuildLinkFn<TRouteTree>\n  state: RouterState<TRouteTree>\n  navigate: NavigateFn<TRouteTree>\n  matchRoute: MatchRouteFn<TRouteTree>\n  routeTree: TRouteTree\n  routesById: RoutesById<TRouteTree>\n  options: RouterOptions<TRouteTree>\n  history: RouterHistory\n  load: LoadFn\n  buildLocation: BuildLocationFn<TRouteTree>\n  subscribe: Router<TRouteTree>['subscribe']\n  resetNextScrollRef: React.MutableRefObject<boolean>\n}\n\nexport const routerContext = React.createContext<RouterContext<any>>(null!)\n\nif (typeof document !== 'undefined') {\n  window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    status: 'idle',\n    resolvedLocation: location,\n    location,\n    matches: [],\n    pendingMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n\nexport function RouterProvider<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>) {\n  const options = {\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context,\n    },\n  } as PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n\n  const history = React.useState(\n    () => options.history ?? createBrowserHistory(),\n  )[0]\n\n  const tempLocationKeyRef = React.useRef<string | undefined>(\n    `${Math.round(Math.random() * 10000000)}`,\n  )\n  const resetNextScrollRef = React.useRef<boolean>(true)\n  const navigateTimeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n  const latestLoadPromiseRef = React.useRef<Promise<void>>(Promise.resolve())\n\n  const checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return latestLoadPromiseRef.current !== promise\n      ? latestLoadPromiseRef.current\n      : undefined\n  }\n\n  const parseLocation = useStableCallback(\n    (\n      previousLocation?: ParsedLocation,\n    ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parse = ({\n        pathname,\n        search,\n        hash,\n        state,\n      }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n        const parsedSearch = options.parseSearch(search)\n\n        return {\n          pathname: pathname,\n          searchStr: search,\n          search: replaceEqualDeep(\n            previousLocation?.search,\n            parsedSearch,\n          ) as any,\n          hash: hash.split('#').reverse()[0] ?? '',\n          href: `${pathname}${search}${hash}`,\n          state: replaceEqualDeep(\n            previousLocation?.state,\n            state,\n          ) as HistoryState,\n        }\n      }\n\n      const location = parse(history.location)\n\n      let { __tempLocation, __tempKey } = location.state\n\n      if (\n        __tempLocation &&\n        (!__tempKey || __tempKey === tempLocationKeyRef.current)\n      ) {\n        // Sync up the location keys\n        const parsedTempLocation = parse(__tempLocation) as any\n        parsedTempLocation.state.key = location.state.key\n\n        delete parsedTempLocation.state.__tempLocation\n\n        return {\n          ...parsedTempLocation,\n          maskedLocation: location,\n        }\n      }\n\n      return location\n    },\n  )\n\n  const latestLocationRef = React.useRef<ParsedLocation>(parseLocation())\n  const [preState, setState] = React.useState<RouterState<TRouteTree>>(() =>\n    getInitialRouterState(latestLocationRef.current),\n  )\n  const [isTransitioning, startReactTransition] = React.useTransition()\n  const pendingMatchesRef = React.useRef<AnyRouteMatch[]>([])\n\n  const state = React.useMemo<RouterState<TRouteTree>>(\n    () => ({\n      ...preState,\n      status: isTransitioning ? 'pending' : 'idle',\n      location: isTransitioning ? latestLocationRef.current : preState.location,\n      pendingMatches: pendingMatchesRef.current,\n    }),\n    [preState, isTransitioning],\n  )\n\n  React.useLayoutEffect(() => {\n    if (!isTransitioning && state.resolvedLocation !== state.location) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: state.resolvedLocation,\n        toLocation: state.location,\n        pathChanged: state.location!.href !== state.resolvedLocation?.href,\n      })\n      pendingMatchesRef.current = []\n\n      setState((s) => ({\n        ...s,\n        resolvedLocation: s.location,\n      }))\n    }\n  })\n\n  const basepath = `/${trimPath(options.basepath ?? '') ?? ''}`\n\n  const resolvePathWithBase = useStableCallback(\n    (from: string, path: string) => {\n      return resolvePath(basepath!, from, cleanPath(path))\n    },\n  )\n\n  const [routesById, routesByPath] = React.useMemo(() => {\n    const routesById = {} as RoutesById<TRouteTree>\n    const routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const recurseRoutes = (routes: AnyRoute[]) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i })\n\n        const existingRoute = (routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(routesById as any)[route.id] = route\n\n        if (!route.isRoot && route.path) {\n          const trimmedFullPath = trimPathRight(route.fullPath)\n          if (\n            !(routesByPath as any)[trimmedFullPath] ||\n            route.fullPath.endsWith('/')\n          ) {\n            ;(routesByPath as any)[trimmedFullPath] = route\n          }\n        }\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([router.routeTree])\n\n    return [routesById, routesByPath] as const\n  }, [])\n\n  const looseRoutesById = routesById as Record<string, AnyRoute>\n\n  const flatRoutes = React.useMemo(\n    () =>\n      (Object.values(routesByPath) as AnyRoute[])\n        .map((d, i) => {\n          const trimmed = trimPath(d.fullPath)\n          const parsed = parsePathname(trimmed)\n\n          while (parsed.length > 1 && parsed[0]?.value === '/') {\n            parsed.shift()\n          }\n\n          const score = parsed.map((d) => {\n            if (d.type === 'param') {\n              return 0.5\n            }\n\n            if (d.type === 'wildcard') {\n              return 0.25\n            }\n\n            return 1\n          })\n\n          return { child: d, trimmed, parsed, index: i, score }\n        })\n        .sort((a, b) => {\n          let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0\n\n          if (isIndex !== 0) return isIndex\n\n          const length = Math.min(a.score.length, b.score.length)\n\n          // Sort by length of score\n          if (a.score.length !== b.score.length) {\n            return b.score.length - a.score.length\n          }\n\n          // Sort by min available score\n          for (let i = 0; i < length; i++) {\n            if (a.score[i] !== b.score[i]) {\n              return b.score[i]! - a.score[i]!\n            }\n          }\n\n          // Sort by min available parsed value\n          for (let i = 0; i < length; i++) {\n            if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n              return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n            }\n          }\n\n          // Sort by length of trimmed full path\n          if (a.trimmed !== b.trimmed) {\n            return a.trimmed > b.trimmed ? 1 : -1\n          }\n\n          // Sort by original index\n          return a.index - b.index\n        })\n        .map((d, i) => {\n          d.child.rank = i\n          return d.child\n        }),\n    [routesByPath],\n  )\n\n  const matchRoutes = useStableCallback(\n    <TRouteTree extends AnyRoute>(\n      pathname: string,\n      locationSearch: AnySearchSchema,\n      opts?: { throwOnError?: boolean; debug?: boolean },\n    ): RouteMatch<TRouteTree>[] => {\n      let routeParams: AnyPathParams = {}\n\n      let foundRoute = flatRoutes.find((route) => {\n        const matchedParams = matchPathname(basepath, trimPathRight(pathname), {\n          to: route.fullPath,\n          caseSensitive: route.options.caseSensitive ?? options.caseSensitive,\n          fuzzy: false,\n        })\n\n        if (matchedParams) {\n          routeParams = matchedParams\n          return true\n        }\n\n        return false\n      })\n\n      let routeCursor: AnyRoute = foundRoute || (routesById as any)['__root__']\n\n      let matchedRoutes: AnyRoute[] = [routeCursor]\n      // let includingLayouts = true\n      while (routeCursor?.parentRoute) {\n        routeCursor = routeCursor.parentRoute\n        if (routeCursor) matchedRoutes.unshift(routeCursor)\n      }\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n\n      const parseErrors = matchedRoutes.map((route) => {\n        let parsedParamsError\n\n        if (route.options.parseParams) {\n          try {\n            const parsedParams = route.options.parseParams(routeParams)\n            // Add the parsed params to the accumulated params bag\n            Object.assign(routeParams, parsedParams)\n          } catch (err: any) {\n            parsedParamsError = new PathParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw parsedParamsError\n            }\n\n            return parsedParamsError\n          }\n        }\n\n        return\n      })\n\n      const matches = matchedRoutes.map((route, index) => {\n        const interpolatedPath = interpolatePath(route.path, routeParams)\n        const matchId = interpolatePath(route.id, routeParams, true)\n\n        // Waste not, want not. If we already have a match for this route,\n        // reuse it. This is important for layout routes, which might stick\n        // around between navigation actions that only change leaf routes.\n        const existingMatch = getRouteMatch(state, matchId)\n\n        if (existingMatch) {\n          return { ...existingMatch }\n        }\n\n        // Create a fresh route match\n        const hasLoaders = !!(\n          route.options.loader ||\n          componentTypes.some((d) => (route.options[d] as any)?.preload)\n        )\n\n        const routeMatch: AnyRouteMatch = {\n          id: matchId,\n          routeId: route.id,\n          params: routeParams,\n          pathname: joinPaths([basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          routeSearch: {},\n          search: {} as any,\n          status: hasLoaders ? 'pending' : 'success',\n          isFetching: false,\n          invalid: false,\n          error: undefined,\n          paramsError: parseErrors[index],\n          searchError: undefined,\n          loadPromise: Promise.resolve(),\n          context: undefined!,\n          abortController: new AbortController(),\n          fetchedAt: 0,\n        }\n\n        return routeMatch\n      })\n\n      // Take each match and resolve its search params and context\n      // This has to happen after the matches are created or found\n      // so that we can use the parent match's search params and context\n      matches.forEach((match, i): any => {\n        const parentMatch = matches[i - 1]\n        const route = looseRoutesById[match.routeId]!\n\n        const searchInfo = (() => {\n          // Validate the search params and stabilize them\n          const parentSearchInfo = {\n            search: parentMatch?.search ?? locationSearch,\n            routeSearch: parentMatch?.routeSearch ?? locationSearch,\n          }\n\n          try {\n            const validator =\n              typeof route.options.validateSearch === 'object'\n                ? route.options.validateSearch.parse\n                : route.options.validateSearch\n\n            let routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n            let search = {\n              ...parentSearchInfo.search,\n              ...routeSearch,\n            }\n\n            routeSearch = replaceEqualDeep(match.routeSearch, routeSearch)\n            search = replaceEqualDeep(match.search, search)\n\n            return {\n              routeSearch,\n              search,\n              searchDidChange: match.routeSearch !== routeSearch,\n            }\n          } catch (err: any) {\n            match.searchError = new SearchParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw match.searchError\n            }\n\n            return parentSearchInfo\n          }\n        })()\n\n        Object.assign(match, searchInfo)\n      })\n\n      return matches as any\n    },\n  )\n\n  const cancelMatch = useStableCallback(\n    <TRouteTree extends AnyRoute>(id: string) => {\n      getRouteMatch(state, id)?.abortController?.abort()\n    },\n  )\n\n  const cancelMatches = useStableCallback(\n    <TRouteTree extends AnyRoute>(state: RouterState<TRouteTree>) => {\n      state.matches.forEach((match) => {\n        cancelMatch(match.id)\n      })\n    },\n  )\n\n  const buildLocation = useStableCallback<BuildLocationFn<TRouteTree>>(\n    (opts) => {\n      const build = (\n        dest: BuildNextOptions & {\n          unmaskOnReload?: boolean\n        } = {},\n        matches?: AnyRouteMatch[],\n      ): ParsedLocation => {\n        const from = latestLocationRef.current\n        const fromPathname = dest.from ?? from.pathname\n\n        let pathname = resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n        const fromMatches = matchRoutes(fromPathname, from.search)\n        const stayingMatches = matches?.filter((d) =>\n          fromMatches?.find((e) => e.routeId === d.routeId),\n        )\n\n        const prevParams = { ...last(fromMatches)?.params }\n\n        let nextParams =\n          (dest.params ?? true) === true\n            ? prevParams\n            : functionalUpdate(dest.params!, prevParams)\n\n        if (nextParams) {\n          matches\n            ?.map((d) => looseRoutesById[d.routeId]!.options.stringifyParams)\n            .filter(Boolean)\n            .forEach((fn) => {\n              nextParams = { ...nextParams!, ...fn!(nextParams!) }\n            })\n        }\n\n        pathname = interpolatePath(pathname, nextParams ?? {})\n\n        const preSearchFilters =\n          stayingMatches\n            ?.map(\n              (match) =>\n                looseRoutesById[match.routeId]!.options.preSearchFilters ?? [],\n            )\n            .flat()\n            .filter(Boolean) ?? []\n\n        const postSearchFilters =\n          stayingMatches\n            ?.map(\n              (match) =>\n                looseRoutesById[match.routeId]!.options.postSearchFilters ?? [],\n            )\n            .flat()\n            .filter(Boolean) ?? []\n\n        // Pre filters first\n        const preFilteredSearch = preSearchFilters?.length\n          ? preSearchFilters?.reduce(\n              (prev, next) => next(prev) as any,\n              from.search,\n            )\n          : from.search\n\n        // Then the link/navigate function\n        const destSearch =\n          dest.search === true\n            ? preFilteredSearch // Preserve resolvedFrom true\n            : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n            ? preFilteredSearch // Preserve resolvedFrom filters\n            : {}\n\n        // Then post filters\n        const postFilteredSearch = postSearchFilters?.length\n          ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n          : destSearch\n\n        const search = replaceEqualDeep(from.search, postFilteredSearch)\n\n        const searchStr = options.stringifySearch(search)\n\n        const hash =\n          dest.hash === true\n            ? from.hash\n            : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n        const hashStr = hash ? `#${hash}` : ''\n\n        let nextState =\n          dest.state === true\n            ? from.state\n            : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n        nextState = replaceEqualDeep(from.state, nextState)\n\n        return {\n          pathname,\n          search,\n          searchStr,\n          state: nextState as any,\n          hash,\n          href: history.createHref(`${pathname}${searchStr}${hashStr}`),\n          unmaskOnReload: dest.unmaskOnReload,\n        }\n      }\n\n      const buildWithMatches = (\n        dest: BuildNextOptions = {},\n        maskedDest?: BuildNextOptions,\n      ) => {\n        let next = build(dest)\n        let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n        if (!maskedNext) {\n          let params = {}\n\n          let foundMask = options.routeMasks?.find((d) => {\n            const match = matchPathname(basepath, next.pathname, {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false,\n            })\n\n            if (match) {\n              params = match\n              return true\n            }\n\n            return false\n          })\n\n          if (foundMask) {\n            foundMask = {\n              ...foundMask,\n              from: interpolatePath(foundMask.from, params) as any,\n            }\n            maskedDest = foundMask\n            maskedNext = build(maskedDest)\n          }\n        }\n\n        const nextMatches = matchRoutes(next.pathname, next.search)\n        const maskedMatches = maskedNext\n          ? matchRoutes(maskedNext.pathname, maskedNext.search)\n          : undefined\n        const maskedFinal = maskedNext\n          ? build(maskedDest, maskedMatches)\n          : undefined\n\n        const final = build(dest, nextMatches)\n\n        if (maskedFinal) {\n          final.maskedLocation = maskedFinal\n        }\n\n        return final\n      }\n\n      if (opts.mask) {\n        return buildWithMatches(opts, {\n          ...pick(opts, ['from']),\n          ...opts.mask,\n        })\n      }\n\n      return buildWithMatches(opts)\n    },\n  )\n\n  const commitLocation = useStableCallback(\n    async ({\n      startTransition,\n      ...next\n    }: ParsedLocation & CommitLocationOptions) => {\n      if (navigateTimeoutRef.current) clearTimeout(navigateTimeoutRef.current)\n\n      const isSameUrl = latestLocationRef.current.href === next.href\n\n      // If the next urls are the same and we're not replacing,\n      // do nothing\n      if (!isSameUrl || !next.replace) {\n        let { maskedLocation, ...nextHistory } = next\n\n        if (maskedLocation) {\n          nextHistory = {\n            ...maskedLocation,\n            state: {\n              ...maskedLocation.state,\n              __tempKey: undefined,\n              __tempLocation: {\n                ...nextHistory,\n                search: nextHistory.searchStr,\n                state: {\n                  ...nextHistory.state,\n                  __tempKey: undefined!,\n                  __tempLocation: undefined!,\n                  key: undefined!,\n                },\n              },\n            },\n          }\n\n          if (nextHistory.unmaskOnReload ?? options.unmaskOnReload ?? false) {\n            nextHistory.state.__tempKey = tempLocationKeyRef.current\n          }\n        }\n\n        const apply = () => {\n          history[next.replace ? 'replace' : 'push'](\n            nextHistory.href,\n            nextHistory.state,\n          )\n        }\n\n        if (startTransition ?? true) {\n          startReactTransition(apply)\n        } else {\n          apply()\n        }\n      }\n\n      resetNextScrollRef.current = next.resetScroll ?? true\n\n      return latestLoadPromiseRef.current\n    },\n  )\n\n  const buildAndCommitLocation = useStableCallback(\n    ({\n      replace,\n      resetScroll,\n      startTransition,\n      ...rest\n    }: BuildNextOptions & CommitLocationOptions = {}) => {\n      const location = buildLocation(rest)\n      return commitLocation({\n        ...location,\n        startTransition,\n        replace,\n        resetScroll,\n      })\n    },\n  )\n\n  const navigate = useStableCallback<NavigateFn<TRouteTree>>(\n    ({ from, to = '', ...rest }) => {\n      // If this link simply reloads the current route,\n      // make sure it has a new key so it will trigger a data refresh\n\n      // If this `to` is a valid external URL, return\n      // null for LinkUtils\n      const toString = String(to)\n      const fromString = typeof from === 'undefined' ? from : String(from)\n      let isExternal\n\n      try {\n        new URL(`${toString}`)\n        isExternal = true\n      } catch (e) {}\n\n      invariant(\n        !isExternal,\n        'Attempting to navigate to external url with this.navigate!',\n      )\n\n      return buildAndCommitLocation({\n        ...rest,\n        from: fromString,\n        to: toString,\n      })\n    },\n  )\n\n  const loadMatches = useStableCallback(\n    async ({\n      checkLatest,\n      matches,\n      preload,\n    }: {\n      checkLatest: () => Promise<void> | undefined\n      matches: AnyRouteMatch[]\n      preload?: boolean\n    }): Promise<RouteMatch[]> => {\n      let latestPromise\n      let firstBadMatchIndex: number | undefined\n\n      // Check each match middleware to see if the route can be accessed\n      try {\n        for (let [index, match] of matches.entries()) {\n          const parentMatch = matches[index - 1]\n          const route = looseRoutesById[match.routeId]!\n\n          const handleError = (err: any, code: string) => {\n            err.routerCode = code\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            try {\n              route.options.onError?.(err)\n            } catch (errorHandlerErr) {\n              err = errorHandlerErr\n\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n            }\n\n            matches[index] = match = {\n              ...match,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }\n          }\n\n          try {\n            if (match.paramsError) {\n              handleError(match.paramsError, 'PARSE_PARAMS')\n            }\n\n            if (match.searchError) {\n              handleError(match.searchError, 'VALIDATE_SEARCH')\n            }\n\n            const parentContext = parentMatch?.context ?? options.context ?? {}\n\n            const beforeLoadContext =\n              (await route.options.beforeLoad?.({\n                search: match.search,\n                abortController: match.abortController,\n                params: match.params,\n                preload: !!preload,\n                context: parentContext,\n                location: state.location,\n                navigate: (opts) =>\n                  navigate({ ...opts, from: match.pathname } as any),\n                buildLocation,\n              })) ?? ({} as any)\n\n            const context = {\n              ...parentContext,\n              ...beforeLoadContext,\n            }\n\n            matches[index] = match = {\n              ...match,\n              context: replaceEqualDeep(match.context, context),\n            }\n          } catch (err) {\n            handleError(err, 'BEFORE_LOAD')\n            break\n          }\n        }\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!preload) navigate(err as any)\n          return matches\n        }\n\n        throw err\n      }\n\n      const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n      const matchPromises: Promise<any>[] = []\n\n      validResolvedMatches.forEach((match, index) => {\n        matchPromises.push(\n          (async () => {\n            const parentMatchPromise = matchPromises[index - 1]\n            const route = looseRoutesById[match.routeId]!\n\n            const handleIfRedirect = (err: any) => {\n              if (isRedirect(err)) {\n                if (!preload) {\n                  navigate(err as any)\n                }\n                return true\n              }\n              return false\n            }\n\n            let loadPromise: Promise<void> | undefined\n\n            matches[index] = match = {\n              ...match,\n              fetchedAt: Date.now(),\n              invalid: false,\n            }\n\n            if (match.isFetching) {\n              loadPromise = getRouteMatch(state, match.id)?.loadPromise\n            } else {\n              matches[index] = match = {\n                ...match,\n                isFetching: true,\n              }\n\n              const componentsPromise = Promise.all(\n                componentTypes.map(async (type) => {\n                  const component = route.options[type]\n\n                  if ((component as any)?.preload) {\n                    await (component as any).preload()\n                  }\n                }),\n              )\n\n              const loaderPromise = route.options.loader?.({\n                params: match.params,\n                search: match.search,\n                preload: !!preload,\n                parentMatchPromise,\n                abortController: match.abortController,\n                context: match.context,\n                location: state.location,\n                navigate: (opts) =>\n                  navigate({ ...opts, from: match.pathname } as any),\n              })\n\n              loadPromise = Promise.all([\n                componentsPromise,\n                loaderPromise,\n              ]).then((d) => d[1])\n            }\n\n            matches[index] = match = {\n              ...match,\n              loadPromise,\n            }\n\n            if (!preload) {\n              setState((s) => ({\n                ...s,\n                matches: s.matches.map((d) => (d.id === match.id ? match : d)),\n              }))\n            }\n\n            try {\n              const loaderData = await loadPromise\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              matches[index] = match = {\n                ...match,\n                error: undefined,\n                status: 'success',\n                isFetching: false,\n                updatedAt: Date.now(),\n                loaderData,\n                loadPromise: undefined,\n              }\n            } catch (error) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n              if (handleIfRedirect(error)) return\n\n              try {\n                route.options.onError?.(error)\n              } catch (onErrorError) {\n                error = onErrorError\n                if (handleIfRedirect(onErrorError)) return\n              }\n\n              matches[index] = match = {\n                ...match,\n                error,\n                status: 'error',\n                isFetching: false,\n                updatedAt: Date.now(),\n              }\n            }\n\n            if (!preload) {\n              setState((s) => ({\n                ...s,\n                matches: s.matches.map((d) => (d.id === match.id ? match : d)),\n              }))\n            }\n          })(),\n        )\n      })\n\n      await Promise.all(matchPromises)\n      return matches\n    },\n  )\n\n  const load = useStableCallback<LoadFn>(async () => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = latestLocationRef.current\n      const prevLocation = state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      cancelMatches(state)\n\n      router.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      // Match the routes\n      let matches: RouteMatch<any, any>[] = matchRoutes(\n        next.pathname,\n        next.search,\n        {\n          debug: true,\n        },\n      )\n\n      pendingMatchesRef.current = matches\n\n      const previousMatches = state.matches\n\n      // Ingest the new matches\n      setState((s) => ({\n        ...s,\n        status: 'pending',\n        location: next,\n        matches,\n      }))\n\n      try {\n        try {\n          // Load the matches\n          await loadMatches({\n            matches,\n            checkLatest: () => checkLatest(promise),\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatchIds = previousMatches.filter(\n          (id) => !pendingMatchesRef.current.includes(id),\n        )\n        const enteringMatchIds = pendingMatchesRef.current.filter(\n          (id) => !previousMatches.includes(id),\n        )\n        const stayingMatchIds = previousMatches.filter((id) =>\n          pendingMatchesRef.current.includes(id),\n        )\n\n        // setState((s) => ({\n        //   ...s,\n        //   status: 'idle',\n        //   resolvedLocation: s.location,\n        // }))\n\n        //\n        ;(\n          [\n            [exitingMatchIds, 'onLeave'],\n            [enteringMatchIds, 'onEnter'],\n            [stayingMatchIds, 'onTransition'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        router.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    latestLoadPromiseRef.current = promise\n\n    return latestLoadPromiseRef.current\n  })\n\n  const preloadRoute = useStableCallback(\n    async (navigateOpts: BuildNextOptions = state.location) => {\n      let next = buildLocation(navigateOpts)\n\n      let matches = matchRoutes(next.pathname, next.search, {\n        throwOnError: true,\n      })\n\n      await loadMatches({\n        matches,\n        preload: true,\n        checkLatest: () => undefined,\n      })\n\n      return [last(matches)!, matches] as const\n    },\n  )\n\n  const buildLink = useStableCallback<BuildLinkFn<TRouteTree>>((dest) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    const {\n      to,\n      preload: userPreload,\n      preloadDelay: userPreloadDelay,\n      activeOptions,\n      disabled,\n      target,\n      replace,\n      resetScroll,\n      startTransition,\n    } = dest\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to as any,\n      }\n    } catch (e) {}\n\n    const nextOpts = dest\n    const next = buildLocation(nextOpts as any)\n\n    const preload = userPreload ?? options.defaultPreload\n    const preloadDelay = userPreloadDelay ?? options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = latestLocationRef.current.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? latestLocationRef.current.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? latestLocationRef.current.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? partialDeepEqual(latestLocationRef.current.search, next.search)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        commitLocation({ ...next, replace, resetScroll, startTransition })\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        preloadRoute(nextOpts as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      preloadRoute(nextOpts as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          preloadRoute(nextOpts as any).catch((err) => {\n            console.warn(err)\n            console.warn(preloadWarning)\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  })\n\n  React.useLayoutEffect(() => {\n    const unsub = history.subscribe(() => {\n      latestLocationRef.current = parseLocation(latestLocationRef.current)\n\n      if (state.location !== latestLocationRef.current) {\n        startReactTransition(() => {\n          try {\n            load()\n          } catch (err) {\n            console.error(err)\n          }\n        })\n      }\n    })\n\n    const nextLocation = buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (state.location.href !== nextLocation.href) {\n      commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [history])\n\n  React.useLayoutEffect(() => {\n    startReactTransition(() => {\n      try {\n        load()\n      } catch (err) {\n        console.error(err)\n      }\n    })\n  }, [])\n\n  const matchRoute = useStableCallback<MatchRouteFn<TRouteTree>>(\n    (location, opts) => {\n      location = {\n        ...location,\n        to: location.to\n          ? resolvePathWithBase((location.from || '') as string, location.to)\n          : undefined,\n      } as any\n\n      const next = buildLocation(location as any)\n\n      if (opts?.pending && state.status !== 'pending') {\n        return false\n      }\n\n      const baseLocation = opts?.pending\n        ? latestLocationRef.current\n        : state.resolvedLocation\n\n      // const baseLocation = state.resolvedLocation\n\n      if (!baseLocation) {\n        return false\n      }\n\n      const match = matchPathname(basepath, baseLocation.pathname, {\n        ...opts,\n        to: next.pathname,\n      }) as any\n\n      if (!match) {\n        return false\n      }\n\n      if (match && (opts?.includeSearch ?? true)) {\n        return partialDeepEqual(baseLocation.search, next.search)\n          ? match\n          : false\n      }\n\n      return match\n    },\n  )\n\n  const routerContextValue: RouterContext<TRouteTree> = {\n    routeTree: router.routeTree,\n    navigate,\n    buildLink,\n    state,\n    matchRoute,\n    routesById,\n    options,\n    history,\n    load,\n    buildLocation,\n    subscribe: router.subscribe,\n    resetNextScrollRef,\n  }\n\n  return (\n    <routerContext.Provider value={routerContextValue}>\n      <Matches />\n    </routerContext.Provider>\n  )\n}\n\nexport function getRouteMatch<TRouteTree extends AnyRoute>(\n  state: RouterState<TRouteTree>,\n  id: string,\n): undefined | RouteMatch<TRouteTree> {\n  return [...state.pendingMatches, ...state.matches].find((d) => d.id === id)\n}\n\nexport function useRouterState<\n  TSelected = RouterState<RegisteredRouter['routeTree']>,\n>(opts?: {\n  select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected\n}): TSelected {\n  const { state } = useRouter()\n  // return useStore(router.__store, opts?.select as any)\n  return opts?.select ? opts.select(state) : (state as any)\n}\n\nexport type RouterProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {\n  router: Router<TRouteTree>\n  context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>\n}\n\nexport function useRouter<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(): RouterContext<TRouteTree> {\n  const resolvedContext = window.__TSR_ROUTER_CONTEXT__ || routerContext\n  const value = React.useContext(resolvedContext)\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!')\n  return value as any\n}\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: RouteById<TRouteTree, TRouteId>['types']['allParams']\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  invalid: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData']\n  __resolveLoadPromise?: () => void\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  routeSearch: RouteById<TRouteTree, TRouteId>['types']['searchSchema']\n  search: FullSearchSchema<TRouteTree> &\n    RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema']\n  fetchedAt: number\n  abortController: AbortController\n}\n\nexport type AnyRouteMatch = RouteMatch<any>\n", "import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { RouteMatch } from './RouterProvider'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { ResolveRelativePath, ToOptions } from './link'\nimport { AnyRoute, ReactNode, rootRouteId } from './route'\nimport { RouteById, RouteByPath, RouteIds, RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { NoInfer, StrictOrFrom, functionalUpdate } from './utils'\n\nexport function Matches() {\n  const { routesById, state } = useRouter()\n  const { matches } = state\n\n  const locationKey = useRouterState().location.state.key\n\n  const route = routesById[rootRouteId]!\n\n  const errorComponent = React.useCallback(\n    (props: any) => {\n      return React.createElement(ErrorComponent, {\n        ...props,\n        useMatch: route.useMatch,\n        useRouteContext: route.useRouteContext,\n        useSearch: route.useSearch,\n        useParams: route.useParams,\n      })\n    },\n    [route],\n  )\n\n  return (\n    <matchesContext.Provider value={matches}>\n      <CatchBoundary\n        resetKey={locationKey}\n        errorComponent={errorComponent}\n        onCatch={() => {\n          warning(\n            false,\n            `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`,\n          )\n        }}\n      >\n        {matches.length ? <Match matches={matches} /> : null}\n      </CatchBoundary>\n    </matchesContext.Provider>\n  )\n}\n\nconst defaultPending = () => null\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matches }: { matches: RouteMatch[] }) {\n  const { options, routesById } = useRouter()\n  const match = matches[0]!\n  const routeId = match?.routeId\n  const route = routesById[routeId]!\n  const locationKey = useRouterState().location.state?.key\n\n  const PendingComponent = (route.options.pendingComponent ??\n    options.defaultPendingComponent ??\n    defaultPending) as any\n\n  const routeErrorComponent =\n    route.options.errorComponent ??\n    options.defaultErrorComponent ??\n    ErrorComponent\n\n  const ResolvedSuspenseBoundary = route.options.wrapInSuspense\n    ? React.Suspense\n    : SafeFragment\n\n  const errorComponent = React.useCallback(\n    (props: any) => {\n      return React.createElement(routeErrorComponent, {\n        ...props,\n        useMatch: route.useMatch,\n        useRouteContext: route.useRouteContext,\n        useSearch: route.useSearch,\n        useParams: route.useParams,\n      })\n    },\n    [route],\n  )\n\n  return (\n    <matchesContext.Provider value={matches}>\n      <ResolvedSuspenseBoundary\n        fallback={React.createElement(PendingComponent, {\n          useMatch: route.useMatch,\n          useRouteContext: route.useRouteContext,\n          useSearch: route.useSearch,\n          useParams: route.useParams,\n        })}\n      >\n        <CatchBoundary\n          resetKey={locationKey}\n          errorComponent={errorComponent}\n          onCatch={() => {\n            warning(false, `Error in route match: ${match.id}`)\n          }}\n        >\n          <MatchInner match={match} />\n        </CatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchesContext.Provider>\n  )\n}\nfunction MatchInner({ match }: { match: RouteMatch }): any {\n  const { options, routesById } = useRouter()\n  const route = routesById[match.routeId]!\n\n  if (match.status === 'error') {\n    throw match.error\n  }\n\n  if (match.status === 'pending') {\n    throw match.loadPromise\n  }\n\n  if (match.status === 'success') {\n    let comp = route.options.component ?? options.defaultComponent\n\n    if (comp) {\n      return React.createElement(comp, {\n        useMatch: route.useMatch,\n        useRouteContext: route.useRouteContext as any,\n        useSearch: route.useSearch,\n        useParams: route.useParams as any,\n        useLoaderData: route.useLoaderData,\n      })\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport function Outlet() {\n  const matches = React.useContext(matchesContext).slice(1)\n\n  if (!matches[0]) {\n    return null\n  }\n\n  return <Match matches={matches} />\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type MakeUseMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<AnyRoute, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions\n\nexport function useMatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>() {\n  const { matchRoute } = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = '/',\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: MakeUseMatchRouteOptions<\n        TRouteTree,\n        TFrom,\n        TTo,\n        TMaskFrom,\n        TMaskTo\n      >,\n    ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, ...rest } = opts\n\n      return matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n      })\n    },\n    [],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ((\n          params?: RouteByPath<\n            TRouteTree,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['types']['allParams'],\n        ) => ReactNode)\n      | React.ReactNode\n  }\n\nexport function MatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return !!params ? props.children : null\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatchState = RouteMatch<TRouteTree, TFrom>,\n  TSelected = TRouteMatchState,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatchState) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  const nearestMatch = React.useContext(matchesContext)[0]!\n  const nearestMatchRouteId = nearestMatch?.routeId\n\n  const matchRouteId = useRouterState({\n    select: (state) => {\n      const match = opts?.from\n        ? state.matches.find((d) => d.routeId === opts?.from)\n        : state.matches.find((d) => d.id === nearestMatch.id)\n\n      return match!.routeId\n    },\n  })\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatchRouteId == matchRouteId,\n      `useMatch(\"${\n        matchRouteId as string\n      }\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${\n        matchRouteId as string\n      }\", { strict: false })' or 'useRoute(\"${\n        matchRouteId as string\n      }\")' instead?`,\n    )\n  }\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = opts?.from\n        ? state.matches.find((d) => d.routeId === opts?.from)\n        : state.matches.find((d) => d.id === nearestMatch.id)\n\n      invariant(\n        match,\n        `Could not find ${\n          opts?.from\n            ? `an active match from \"${opts.from}\"`\n            : 'a nearest match!'\n        }`,\n      )\n\n      return opts?.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as any\n}\n\nexport const matchesContext = React.createContext<RouteMatch[]>(null!)\n\nexport function useMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  const contextMatches = React.useContext(matchesContext)\n\n  return useRouterState({\n    select: (state) => {\n      const matches = state.matches.slice(\n        state.matches.findIndex((d) => d.id === contextMatches[0]?.id),\n      )\n      return opts?.select ? opts.select(matches) : (matches as T)\n    },\n  })\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = TRouteMatch['loaderData'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  const match = useMatch({ ...opts, select: undefined })!\n\n  return typeof opts.select === 'function'\n    ? opts.select(match?.loaderData)\n    : match?.loaderData\n}\n", "import { AnyRoute } from './route'\nimport { RouteIds, RouteById, AllParams } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { last } from './utils'\nimport { useRouterState } from './RouterProvider'\nimport { StrictOrFrom } from './utils'\n\nexport function useParams<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TDefaultSelected = AllParams<TRouteTree> &\n    RouteById<TRouteTree, TFrom>['types']['allParams'],\n  TSelected = TDefaultSelected,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TDefaultSelected) => TSelected\n  },\n): TSelected {\n  return useRouterState({\n    select: (state: any) => {\n      const params = (last(state.matches) as any)?.params\n      return opts?.select ? opts.select(params) : params\n    },\n  })\n}\n", "import { AnyRoute } from './route'\nimport { RouteIds, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { RouteMatch } from './RouterProvider'\nimport { useMatch } from './Matches'\nimport { StrictOrFrom } from './utils'\n\nexport function useSearch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TSearch = RouteById<TRouteTree, TFrom>['types']['fullSearchSchema'],\n  TSelected = TSearch,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TSearch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) => {\n      return opts?.select ? opts.select(match.search as TSearch) : match.search\n    },\n  })\n}\n", "import { HistoryLocation } from '@tanstack/history'\nimport * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useLoaderData, useMatch } from './Matches'\nimport { AnyRouteMatch } from './RouterProvider'\nimport { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { joinPaths, trimPath } from './path'\nimport { RoutePaths } from './routeInfo'\nimport { AnyRouter } from './router'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport { BuildLocationFn, NavigateFn } from './RouterProvider'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport interface RouteMeta {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = AnyPathParams,\n  TAllParams extends AnyPathParams = TParams,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchema,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContext,\n  TAllContext,\n  TLoaderData\n> &\n  NoInfer<\n    UpdatableRouteOptions<\n      TFullSearchSchema,\n      TAllParams,\n      TAllContext,\n      TLoaderData\n    >\n  >\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\ntype Prefix<T extends string, U extends string> = U extends `${T}${infer _}`\n  ? U\n  : never\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = RoutePathOptions<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  validateSearch?: SearchSchemaValidator<TSearchSchema>\n} & (keyof PickRequired<RouteContext> extends never\n    ? // This async function is called before a route is loaded.\n      // If an error is thrown here, the route's loader will not be called.\n      // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n      // If thrown during a preload event, the error will be logged to the console.\n      {\n        beforeLoad?: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }\n    : {\n        beforeLoad: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }) & {\n    loader?: RouteLoadFn<\n      TAllParams,\n      TFullSearchSchema,\n      NoInfer<TAllContext>,\n      NoInfer<TRouteContext>,\n      TLoaderData\n    >\n  } & (\n    | {\n        // Both or none\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<ParamsFallback<TPath, TParams>>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  )\n\ntype BeforeLoadFn<\n  TFullSearchSchema extends Record<string, any>,\n  TParentRoute extends AnyRoute,\n  TAllParams,\n  TRouteContext,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TParentRoute['types']['allContext']\n  location: ParsedLocation\n  navigate: NavigateFn<AnyRoute>\n  buildLocation: BuildLocationFn<AnyRoute>\n}) => Promise<TRouteContext> | TRouteContext | void\n\nexport type UpdatableRouteOptions<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends AnyContext,\n  TLoaderData extends any = unknown,\n> = MetaOptions & {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent<\n    TFullSearchSchema,\n    TAllParams,\n    TAllContext,\n    TLoaderData\n  >\n  // The content to be rendered when the route encounters an error\n  errorComponent?: ErrorRouteComponent<\n    TFullSearchSchema,\n    TAllParams,\n    {}\n    // TAllContext // TODO: I have no idea why this breaks the universe,\n    // so we'll come back to it later.\n  > //\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: PendingRouteComponent<\n    TFullSearchSchema,\n    TAllParams,\n    TAllContext\n  >\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: AnyRouteMatch) => void\n  onTransition?: (match: AnyRouteMatch) => void\n  onLeave?: (match: AnyRouteMatch) => void\n  // Set this to true or false to specifically set whether or not this route should be preloaded. If unset, will\n  // default to router.options.reloadOnWindowFocus\n  reloadOnWindowFocus?: boolean\n}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn> =\n  | SearchSchemaValidatorObj<TReturn>\n  | SearchSchemaValidatorFn<TReturn>\n\nexport type SearchSchemaValidatorObj<TReturn> = {\n  parse?: SearchSchemaValidatorFn<TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TReturn> = (\n  searchObj: Record<string, unknown>,\n) => TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type RouteLoadFn<\n  TAllParams = {},\n  TFullSearchSchema extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = (\n  match: LoaderFnContext<\n    TAllParams,\n    TFullSearchSchema,\n    TAllContext,\n    TRouteContext\n  > & {\n    parentMatchPromise?: Promise<void>\n  },\n) => Promise<TLoaderData> | TLoaderData\n\nexport interface LoaderFnContext<\n  TAllParams = {},\n  TFullSearchSchema extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  search: TFullSearchSchema\n  context: Expand<Assign<TAllContext, TRouteContext>>\n  location: ParsedLocation<TFullSearchSchema>\n  navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>\n}\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<\n  Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type StreamedPromise<T> = {\n  promise: Promise<T>\n  status: 'resolved' | 'pending'\n  data: T\n  resolve: (value: T) => void\n}\n\nexport type ResolveAllParams<\n  TParentRoute extends AnyRoute,\n  TParams extends AnyPathParams,\n> = Record<never, string> extends TParentRoute['types']['allParams']\n  ? TParams\n  : Expand<\n      UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n    >\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport class Route<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TLoaderData\n  >\n\n  test!: Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n    Route.__onInit(this)\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routeTree: TRouteTree\n    routerContext: TRouterContext\n    loaderData: TLoaderData\n  }\n\n  init = (opts: { originalIndex: number }) => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderData\n    > &\n      RoutePathOptionsIntersection<TCustomId, TPath>\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TNewChildren,\n    TRouteTree\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  update = (\n    options: UpdatableRouteOptions<\n      TFullSearchSchema,\n      TAllParams,\n      Expand<\n        Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n      >,\n      TLoaderData\n    >,\n  ) => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  static __onInit = (route: any) => {\n    // This is a dummy static method that should get\n    // replaced by a framework specific implementation if necessary\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any>\n\nexport function rootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchema extends Record<string, any> = {},\n    TRouteContext extends RouteContext = RouteContext,\n    TLoaderData extends any = unknown,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderData // TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ): RootRoute<TSearchSchema, TRouteContext, TRouterContext> => {\n    return new RootRoute(options) as any\n  }\n}\n\nexport class RootRoute<\n  TSearchSchema extends Record<string, any> = {},\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n  TLoaderData extends any = unknown,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchema, // TSearchSchema\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContext, // TRouteContext\n  Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext\n  TRouterContext, // TRouterContext\n  TLoaderData,\n  any, // TChildren\n  any // TRouteTree\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n  ? TPrefix extends RootRouteId\n    ? TPath extends '/'\n      ? '/'\n      : `/${TrimPath<TPath>}`\n    : `${TPrefix}/${TPath}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n  : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n    ? TrimPathLeft<U>\n    : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<TRouteTree, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport type RouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = {\n  useMatch: <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }) => TSelected\n  useRouteContext: <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }) => TSelected\n  useSearch: <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }) => TSelected\n  useParams: <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }) => TSelected\n  useLoaderData: <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }) => TSelected\n}\n\nexport type ErrorRouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n> = {\n  error: unknown\n  info: { componentStack: string }\n} & RouteProps<TFullSearchSchema, TAllParams, TAllContext>\n\nexport type PendingRouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n> = RouteProps<TFullSearchSchema, TAllParams, TAllContext>\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n  TLoaderData extends any = unknown,\n> = AsyncRouteComponent<\n  RouteProps<TFullSearchSchema, TAllParams, TAllContext, TLoaderData>\n>\n\nexport type ErrorRouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n> = AsyncRouteComponent<\n  ErrorRouteProps<TFullSearchSchema, TAllParams, TAllContext>\n>\n\nexport type PendingRouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n> = AsyncRouteComponent<\n  PendingRouteProps<TFullSearchSchema, TAllParams, TAllContext>\n>\n\nexport type AnyRouteComponent = RouteComponent<any, any, any, any>\n", "import { ParsePathParams } from './link'\nimport {\n  AnyRoute,\n  ResolveFullPath,\n  ResolveFullSearchSchema,\n  MergeFromFromParent,\n  RouteContext,\n  AnyContext,\n  RouteOptions,\n  UpdatableRouteOptions,\n  Route,\n  AnyPathParams,\n  RootRouteId,\n  TrimPathLeft,\n  RouteConstraints,\n} from './route'\nimport { Assign, AssignAll, Expand, IsAny } from './utils'\n\nexport interface FileRoutesByPath {\n  // '/': {\n  //   parentRoute: typeof rootRoute\n  // }\n}\n\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string,\n> = S extends `${infer Start}${From}${infer Rest}`\n  ? `${Start}${To}${Replace<Rest, From, To>}`\n  : S\n\nexport type TrimLeft<\n  T extends string,\n  S extends string,\n> = T extends `${S}${infer U}` ? U : T\n\nexport type TrimRight<\n  T extends string,\n  S extends string,\n> = T extends `${infer U}${S}` ? U : T\n\nexport type Trim<T extends string, S extends string> = TrimLeft<\n  TrimRight<T, S>,\n  S\n>\n\nexport type RemoveUnderScores<T extends string> = Replace<\n  Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>,\n  '/_',\n  '/'\n>\n\nexport type ResolveFilePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = TParentRoute['id'] extends RootRouteId\n  ? TrimPathLeft<TFilePath>\n  : Replace<\n      TrimPathLeft<TFilePath>,\n      TrimPathLeft<TParentRoute['types']['customId']>,\n      ''\n    >\n\nexport type FileRoutePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = ResolveFilePath<TParentRoute, TFilePath> extends `_${infer _}`\n  ? string\n  : ResolveFilePath<TParentRoute, TFilePath>\n\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = TFilePath,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    RemoveUnderScores<TPath>\n  >,\n> {\n  constructor(public path: TFilePath) {}\n\n  createRoute = <\n    TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n    TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n      TParentRoute,\n      TSearchSchema\n    >,\n    TParams extends RouteConstraints['TParams'] = ParsePathParams<TPath> extends never\n      ? AnyPathParams\n      : Record<ParsePathParams<TPath>, RouteConstraints['TPath']>,\n    TAllParams extends RouteConstraints['TAllParams'] = MergeFromFromParent<\n      TParentRoute['types']['allParams'],\n      TParams\n    >,\n    TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n    TContext extends Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    > = Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    >,\n    TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n    TLoaderData extends any = unknown,\n    TChildren extends RouteConstraints['TChildren'] = unknown,\n    TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n  >(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchema,\n        TFullSearchSchema,\n        TParams,\n        TAllParams,\n        TRouteContext,\n        TContext,\n        TLoaderData\n      >,\n      'getParentRoute' | 'path' | 'id'\n    > &\n      UpdatableRouteOptions<\n        TFullSearchSchema,\n        TAllParams,\n        TContext,\n        TLoaderData\n      >,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TLoaderData,\n    TChildren,\n    TRouteTree\n  > => {\n    const route = new Route(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n", "import * as React from 'react'\nimport { AsyncRouteComponent } from './route'\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any>\n\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer()\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = React.lazy(async () => {\n    const moduleExports = await load()\n    const comp = moduleExports[exportName ?? 'default']\n    return {\n      default: comp,\n    }\n  })\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n", "import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { Trim } from './fileRoute'\nimport { LocationState, ParsedLocation } from './location'\nimport { AnyRoute, ReactNode } from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { MakeLinkOptions, MakeLinkPropsOptions } from './useNavigate'\nimport {\n  Expand,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  UnionToIntersection,\n  Updater,\n  functionalUpdate,\n} from './utils'\n\nexport type LinkInfo =\n  | {\n      type: 'external'\n      href: string\n    }\n  | {\n      type: 'internal'\n      next: ParsedLocation\n      handleFocus: (e: any) => void\n      handleClick: (e: any) => void\n      handleEnter: (e: any) => void\n      handleLeave: (e: any) => void\n      handleTouchStart: (e: any) => void\n      isActive: boolean\n      disabled?: boolean\n    }\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n  ? `${CleanPath<L>}/`\n  : T extends `//${infer L}`\n  ? `/${CleanPath<L>}`\n  : T\n\nexport type Split<S, TIncludeTrailingSlash = true> = S extends unknown\n  ? string extends S\n    ? string[]\n    : S extends string\n    ? CleanPath<S> extends ''\n      ? []\n      : TIncludeTrailingSlash extends true\n      ? CleanPath<S> extends `${infer T}/`\n        ? [...Split<T>, '/']\n        : CleanPath<S> extends `/${infer U}`\n        ? Split<U>\n        : CleanPath<S> extends `${infer T}/${infer U}`\n        ? [...Split<T>, ...Split<U>]\n        : [S]\n      : CleanPath<S> extends `${infer T}/${infer U}`\n      ? [...Split<T>, ...Split<U>]\n      : S extends string\n      ? [S]\n      : never\n    : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L : never]: K\n}\n\nexport type Join<T, Delimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n  ? L\n  : T extends [infer L extends string, ...infer Tail extends [...string[]]]\n  ? CleanPath<`${L}${Delimiter}${Join<Tail>}`>\n  : never\n\nexport type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never\n\nexport type RelativeToPathAutoComplete<\n  AllPaths extends string,\n  TFrom extends string,\n  TTo extends string,\n  SplitPaths extends string[] = Split<AllPaths, false>,\n> = TTo extends `..${infer _}`\n  ? SplitPaths extends [\n      ...Split<ResolveRelativePath<TFrom, TTo>, false>,\n      ...infer TToRest,\n    ]\n    ? `${CleanPath<\n        Join<\n          [\n            ...Split<TTo, false>,\n            ...(\n              | TToRest\n              | (Split<\n                  ResolveRelativePath<TFrom, TTo>,\n                  false\n                >['length'] extends 1\n                  ? never\n                  : ['../'])\n            ),\n          ]\n        >\n      >}`\n    : never\n  : TTo extends `./${infer RestTTo}`\n  ? SplitPaths extends [\n      ...Split<TFrom, false>,\n      ...Split<RestTTo, false>,\n      ...infer RestPath,\n    ]\n    ? `${TTo}${Join<RestPath>}`\n    : never\n  :\n      | (TFrom extends `/`\n          ? never\n          : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath]\n          ? Join<RestPath> extends { length: 0 }\n            ? never\n            : './'\n          : never)\n      | (TFrom extends `/` ? never : '../')\n      | AllPaths\n\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TFrom, TTo> & {\n  mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n> = {\n  to?: ToPathOption<TRouteTree, TFrom, TTo>\n  // The new has string or a function to update it\n  hash?: true | Updater<string>\n  // State to pass to the history stack\n  state?: true | NonNullableUpdater<LocationState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: TFrom\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n  // fromCurrent?: boolean\n} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> &\n  SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> &\n  PathParamOptions<TRouteTree, TFrom, TResolved>\n\nexport type SearchParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  TFromSearchEnsured = '/' extends TFrom\n    ? FullSearchSchema<TRouteTree>\n    : Expand<\n        UnionToIntersection<\n          PickRequired<\n            RouteByPath<TRouteTree, TFrom>['types']['fullSearchSchema']\n          >\n        >\n      >,\n  TFromSearchOptional = Omit<AllParams<TRouteTree>, keyof TFromSearchEnsured>,\n  TFromSearch = Expand<TFromSearchEnsured & TFromSearchOptional>,\n  TToSearch = '' extends TTo\n    ? FullSearchSchema<TRouteTree>\n    : Expand<RouteByPath<TRouteTree, TResolved>['types']['fullSearchSchema']>,\n> = keyof PickRequired<TToSearch> extends never\n  ? {\n      search?: true | SearchReducer<TFromSearch, TToSearch>\n    }\n  : {\n      search: TFromSearchEnsured extends PickRequired<TToSearch>\n        ? true | SearchReducer<TFromSearch, TToSearch>\n        : SearchReducer<TFromSearch, TToSearch>\n    }\n\ntype SearchReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type PathParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TFromParamsEnsured = Expand<\n    UnionToIntersection<\n      PickRequired<RouteByPath<TRouteTree, TFrom>['types']['allParams']>\n    >\n  >,\n  TFromParamsOptional = Omit<AllParams<TRouteTree>, keyof TFromParamsEnsured>,\n  TFromParams = Expand<TFromParamsOptional & TFromParamsEnsured>,\n  TToParams = Expand<RouteByPath<TRouteTree, TTo>['types']['allParams']>,\n> = keyof PickRequired<TToParams> extends never\n  ? {\n      params?: true | ParamsReducer<TFromParams, TToParams>\n    }\n  : {\n      params: TFromParamsEnsured extends PickRequired<TToParams>\n        ? true | ParamsReducer<TFromParams, TToParams>\n        : ParamsReducer<TFromParams, TToParams>\n    }\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type ToPathOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RoutePaths<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type ToIdOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RouteIds<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckRelativePath<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n> = TTo extends string\n  ? TFrom extends string\n    ? ResolveRelativePath<TFrom, TTo> extends RoutePaths<TRouteTree>\n      ? {}\n      : {\n          Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<\n            TFrom,\n            TTo\n          >}, which is not a valid route path.`\n          'Valid Route Paths': RoutePaths<TRouteTree>\n        }\n    : {}\n  : {}\n\nexport type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RoutePaths<TRouteTree>\n> extends never\n  ? TPass\n  : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>\n\nexport type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {\n  to: RoutePaths<TRouteTree>\n}\n\nexport type CheckId<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RouteIds<TRouteTree>\n> extends never\n  ? TPass\n  : CheckIdError<TRouteTree, Exclude<TPath, RouteIds<TRouteTree>>>\n\nexport type CheckIdError<TRouteTree extends AnyRoute, TInvalids> = {\n  Error: `${TInvalids extends string\n    ? TInvalids\n    : never} is not a valid route ID.`\n  'Valid Route IDs': RouteIds<TRouteTree>\n}\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n      ? Join<[TFrom, '/']>\n      : TTo extends `./${infer TRest}`\n      ? ResolveRelativePath<TFrom, TRest>\n      : TTo extends `/${infer TRest}`\n      ? TTo\n      : Split<TTo> extends ['..', ...infer ToRest]\n      ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n        ? ToRest extends ['/']\n          ? Join<[...FromRest, '/']>\n          : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n        : never\n      : Split<TTo> extends ['.', ...infer ToRest]\n      ? ToRest extends ['/']\n        ? Join<[TFrom, '/']>\n        : ResolveRelativePath<TFrom, Join<ToRest>>\n      : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\nexport function useLinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  options: MakeLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const { buildLink } = useRouter()\n  const match = useMatch({\n    strict: false,\n  })\n\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload,\n    preloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  const linkInfo = buildLink({\n    from: options.to ? match.pathname : undefined,\n    ...options,\n  } as any)\n\n  if (linkInfo.type === 'external') {\n    const { href } = linkInfo\n    return { href }\n  }\n\n  const {\n    handleClick,\n    handleFocus,\n    handleEnter,\n    handleLeave,\n    handleTouchStart,\n    isActive,\n    next,\n  } = linkInfo\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n      ? next.maskedLocation.href\n      : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkComponent<TProps extends Record<string, any> = {}> {\n  <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    props: MakeLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n      TProps &\n      React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkComponent = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n", "import * as React from 'react'\n\nconst useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nimport { ParsedLocation } from './location'\nimport { useRouter } from './RouterProvider'\nimport { NonNullableUpdater, functionalUpdate } from './utils'\n\nconst windowKey = 'window'\nconst delimiter = '___'\n\nlet weakScrolledElements = new WeakSet<any>()\n\ntype CacheValue = Record<string, { scrollX: number; scrollY: number }>\ntype CacheState = {\n  cached: CacheValue\n  next: CacheValue\n}\n\ntype Cache = {\n  state: CacheState\n  set: (updater: NonNullableUpdater<CacheState>) => void\n}\n\nlet cache: Cache\n\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage\n\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n}\n\nconst defaultGetKey = (location: ParsedLocation) => location.state.key!\n\nexport function useScrollRestoration(options?: ScrollRestorationOptions) {\n  const { state, subscribe, resetNextScrollRef } = useRouter()\n\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey\n\n    if (sessionsStorage) {\n      if (!cache) {\n        cache = (() => {\n          const storageKey = 'tsr-scroll-restoration-v2'\n\n          const state: CacheState = JSON.parse(\n            window.sessionStorage.getItem(storageKey) || 'null',\n          ) || { cached: {}, next: {} }\n\n          return {\n            state,\n            set: (updater) => {\n              cache.state = functionalUpdate(updater, cache.state)\n              window.sessionStorage.setItem(\n                storageKey,\n                JSON.stringify(cache.state),\n              )\n            },\n          }\n        })()\n      }\n    }\n\n    const { history } = window\n    if (history.scrollRestoration) {\n      history.scrollRestoration = 'manual'\n    }\n\n    const onScroll = (event: Event) => {\n      if (weakScrolledElements.has(event.target)) return\n      weakScrolledElements.add(event.target)\n\n      const elementSelector =\n        event.target === document || event.target === window\n          ? windowKey\n          : getCssSelector(event.target)\n\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN,\n            },\n          },\n        }))\n      }\n    }\n\n    const getCssSelector = (el: any): string => {\n      let path = [],\n        parent\n      while ((parent = el.parentNode)) {\n        path.unshift(\n          `${el.tagName}:nth-child(${\n            ([].indexOf as any).call(parent.children, el) + 1\n          })`,\n        )\n        el = parent\n      }\n      return `${path.join(' > ')}`.toLowerCase()\n    }\n\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true)\n    }\n\n    const unsubOnBeforeLoad = subscribe('onBeforeLoad', (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation)\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector]!\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0\n            entry.scrollY = window.scrollY || 0\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector)\n            entry.scrollX = element?.scrollLeft || 0\n            entry.scrollY = element?.scrollTop || 0\n          }\n\n          cache.set((c) => {\n            const next = { ...c.next }\n            delete next[elementSelector]\n\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry,\n              },\n            }\n          })\n        }\n      }\n    })\n\n    const unsubOnResolved = subscribe('onResolved', (event) => {\n      if (event.pathChanged) {\n        if (!resetNextScrollRef.current) {\n          return\n        }\n\n        resetNextScrollRef.current = true\n\n        const getKey = options?.getKey || defaultGetKey\n\n        const restoreKey = getKey(event.toLocation)\n        let windowRestored = false\n\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey]!\n          const [key, elementSelector] = cacheKey.split(delimiter)\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true\n              window.scrollTo(entry.scrollX, entry.scrollY)\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector)\n              if (element) {\n                element.scrollLeft = entry.scrollX\n                element.scrollTop = entry.scrollY\n              }\n            }\n          }\n        }\n\n        if (!windowRestored) {\n          window.scrollTo(0, 0)\n        }\n\n        cache.set((c) => ({ ...c, next: {} }))\n        weakScrolledElements = new WeakSet<any>()\n      }\n    })\n\n    return () => {\n      document.removeEventListener('scroll', onScroll)\n      unsubOnBeforeLoad()\n      unsubOnResolved()\n    }\n  }, [])\n}\n\nexport function ScrollRestoration(props: ScrollRestorationOptions) {\n  useScrollRestoration(props)\n  return null\n}\n", "import * as React from 'react'\nimport { ReactNode } from './route'\nimport { useRouter } from './RouterProvider'\n\nexport function useBlocker(\n  message: string,\n  condition: boolean | any = true,\n): void {\n  const { history } = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n\n    let unblock = history.block((retry, cancel) => {\n      if (window.confirm(message)) {\n        unblock()\n        retry()\n      }\n    })\n\n    return unblock\n  })\n}\n\nexport function Block({ message, condition, children }: PromptProps) {\n  useBlocker(message, condition)\n  return (children ?? null) as ReactNode\n}\n\nexport type PromptProps = {\n  message: string\n  condition?: boolean | any\n  children?: ReactNode\n}\n", "import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { LinkOptions, NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { useLayoutEffect } from './utils'\n\nexport function useNavigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const { navigate } = useRouter()\n  const match = useMatch({\n    strict: false,\n  })\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n    >(\n      opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ) => {\n      return navigate({\n        from: opts?.to ? match.pathname : undefined,\n        ...defaultOpts,\n        ...(opts as any),\n      })\n    },\n    [],\n  )\n}\n\nexport function typedNavigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n>(navigate: (opts: NavigateOptions<any>) => Promise<void>) {\n  return navigate as <\n    TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n  ) => Promise<void>\n} //\n\nexport function Navigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(props: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): null {\n  const { navigate } = useRouter()\n  const match = useMatch({ strict: false })\n\n  useLayoutEffect(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props,\n    } as any)\n  }, [])\n\n  return null\n}\n\nexport type MakeLinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type MakeLinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\nexport type LinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n"],
  "mappings": "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",
  "names": ["pushStateEvent", "popStateEvent", "beforeUnloadEvent", "beforeUnloadListener", "event", "preventDefault", "returnValue", "stopBlocking", "removeEventListener", "capture", "createHistory", "opts", "location", "getLocation", "subscribers", "Set", "blockers", "queue", "onUpdate", "forEach", "subscriber", "tryUnblock", "length", "shift", "queueTask", "task", "push", "subscribe", "cb", "add", "delete", "path", "state", "assignKey", "pushState", "replace", "replaceState", "go", "index", "back", "forward", "createHref", "str", "block", "addEventListener", "filter", "b", "flush", "destroy", "notify", "key", "createRandomKey", "createBrowserHistory", "getHref", "window", "pathname", "search", "hash", "currentLocation", "parseLocation", "history", "next", "tracking", "scheduled", "untrack", "fn", "isPush", "href", "undefined", "queueHistoryAction", "type", "Promise", "resolve", "then", "onPushPop", "originalPushState", "originalReplaceState", "n", "res", "apply", "arguments", "createHashHistory", "substring", "createMemoryHistory", "initialEntries", "entries", "initialIndex", "currentState", "Math", "min", "hashIndex", "indexOf", "searchIndex", "slice", "random", "toString", "isProduction", "CatchBoundary", "props", "errorComponent", "ErrorComponent", "createElement", "CatchBoundaryImpl", "resetKey", "onCatch", "children", "error", "Component", "state", "getDerivedStateFromError", "componentDidUpdate", "prevProps", "prevState", "setState", "componentDidCatch", "console", "render", "show", "setShow", "useState", "process", "style", "padding", "maxWidth", "display", "alignItems", "gap", "fontSize", "appearance", "border", "fontWeight", "borderRadius", "onClick", "d", "height", "color", "overflow", "message", "isServer", "document", "last", "arr", "length", "isFunction", "functionalUpdate", "updater", "previous", "pick", "parent", "keys", "reduce", "obj", "key", "replaceEqualDeep", "prev", "_next", "next", "array", "Array", "isArray", "isPlainObject", "prevSize", "Object", "nextItems", "nextSize", "copy", "equalItems", "i", "o", "hasObjectPrototype", "ctor", "constructor", "prot", "prototype", "hasOwnProperty", "toString", "call", "partialDeepEqual", "a", "b", "some", "item", "index", "useStableCallback", "fn", "fnRef", "useRef", "current", "ref", "args", "shallow", "objA", "objB", "is", "keysA", "useRouteContext", "opts", "useMatch", "select", "match", "context", "useLayoutEffect", "window", "useEffect", "joinPaths", "paths", "cleanPath", "filter", "Boolean", "join", "path", "replace", "trimPathLeft", "trimPathRight", "trimPath", "resolvePath", "basepath", "base", "to", "RegExp", "baseSegments", "parsePathname", "toSegments", "forEach", "toSegment", "value", "push", "pop", "joined", "map", "pathname", "segments", "slice", "substring", "type", "split", "part", "charAt", "interpolatePath", "params", "leaveWildcards", "interpolatedPathSegments", "segment", "matchPathname", "currentPathname", "matchLocation", "pathParams", "matchByPath", "from", "routeSegments", "startsWith", "unshift", "isMatch", "Math", "max", "baseSegment", "routeSegment", "isLastBaseSegment", "isLastRouteSegment", "caseSensitive", "toLowerCase", "fuzzy", "undefined", "redirect", "isRedirect", "encode", "pfx", "k", "tmp", "str", "encodeURIComponent", "toValue", "mix", "decodeURIComponent", "decode", "out", "shift", "concat", "defaultParseSearch", "parseSearchWith", "JSON", "parse", "defaultStringifySearch", "stringifySearchWith", "stringify", "parser", "searchStr", "query", "err", "stringifyValue", "val", "search", "componentTypes", "Router", "options", "subscribers", "Set", "subscribe", "eventType", "listener", "add", "delete", "emit", "routerEvent", "defaultPreloadDelay", "stringifySearch", "parseSearch", "routeTree", "lazyFn", "imported", "routerContext", "createContext", "__TSR_ROUTER_CONTEXT__", "preloadWarning", "isCtrlEvent", "e", "metaKey", "altKey", "ctrlKey", "shiftKey", "SearchParamError", "Error", "PathParamError", "getInitialRouterState", "location", "status", "resolvedLocation", "matches", "pendingMatches", "lastUpdated", "Date", "now", "RouterProvider", "router", "rest", "history", "createBrowserHistory", "tempLocationKeyRef", "round", "random", "resetNextScrollRef", "navigateTimeoutRef", "latestLoadPromiseRef", "Promise", "resolve", "checkLatest", "promise", "parseLocation", "previousLocation", "hash", "parsedSearch", "reverse", "href", "__tempLocation", "__tempKey", "parsedTempLocation", "maskedLocation", "latestLocationRef", "preState", "isTransitioning", "startReactTransition", "useTransition", "pendingMatchesRef", "useMemo", "React", "fromLocation", "toLocation", "pathChanged", "s", "resolvePathWithBase", "routesById", "routesByPath", "recurseRoutes", "routes", "route", "init", "originalIndex", "existingRoute", "id", "invariant", "String", "isRoot", "trimmedFullPath", "fullPath", "endsWith", "looseRoutesById", "flatRoutes", "values", "trimmed", "parsed", "score", "child", "sort", "isIndex", "min", "rank", "matchRoutes", "locationSearch", "routeParams", "foundRoute", "find", "matchedParams", "routeCursor", "matchedRoutes", "parentRoute", "parseErrors", "parsedParamsError", "parseParams", "parsedParams", "assign", "cause", "throwOnError", "interpolatedPath", "matchId", "existingMatch", "getRouteMatch", "hasLoaders", "loader", "preload", "routeMatch", "routeId", "updatedAt", "routeSearch", "isFetching", "invalid", "paramsError", "searchError", "loadPromise", "abortController", "AbortController", "fetchedAt", "parentMatch", "searchInfo", "parentSearchInfo", "validator", "validateSearch", "searchDidChange", "cancelMatch", "abort", "cancelMatches", "buildLocation", "build", "dest", "fromPathname", "fromMatches", "stayingMatches", "prevParams", "nextParams", "stringifyParams", "preSearchFilters", "flat", "postSearchFilters", "preFilteredSearch", "destSearch", "postFilteredSearch", "hashStr", "nextState", "createHref", "unmaskOnReload", "buildWithMatches", "maskedDest", "maskedNext", "foundMask", "routeMasks", "nextMatches", "maskedMatches", "maskedFinal", "final", "mask", "commitLocation", "startTransition", "clearTimeout", "isSameUrl", "nextHistory", "apply", "resetScroll", "buildAndCommitLocation", "navigate", "fromString", "isExternal", "URL", "loadMatches", "latestPromise", "firstBadMatchIndex", "entries", "handleError", "code", "routerCode", "onError", "errorHandlerErr", "parentContext", "beforeLoadContext", "beforeLoad", "validResolvedMatches", "matchPromises", "parentMatchPromise", "handleIfRedirect", "componentsPromise", "all", "component", "loaderPromise", "then", "loaderData", "onErrorError", "load", "reject", "prevLocation", "pathDidChange", "debug", "previousMatches", "exitingMatchIds", "includes", "enteringMatchIds", "stayingMatchIds", "hook", "preloadRoute", "navigateOpts", "buildLink", "userPreload", "preloadDelay", "userPreloadDelay", "activeOptions", "disabled", "target", "nextOpts", "defaultPreload", "currentPathSplit", "nextPathSplit", "pathIsFuzzyEqual", "every", "pathTest", "exact", "hashTest", "includeHash", "searchTest", "includeSearch", "isActive", "handleClick", "defaultPrevented", "button", "preventDefault", "handleFocus", "catch", "warn", "handleTouchStart", "handleEnter", "preloadTimeout", "setTimeout", "handleLeave", "unsub", "nextLocation", "matchRoute", "pending", "baseLocation", "routerContextValue", "Provider", "Matches", "useRouterState", "useRouter", "resolvedContext", "useContext", "warning", "locationKey", "rootRouteId", "useCallback", "useSearch", "useParams", "matchesContext", "Match", "defaultPending", "SafeFragment", "Fragment", "PendingComponent", "pendingComponent", "defaultPendingComponent", "routeErrorComponent", "defaultErrorComponent", "ResolvedSuspenseBoundary", "wrapInSuspense", "Suspense", "fallback", "MatchInner", "comp", "defaultComponent", "useLoaderData", "Outlet", "useMatchRoute", "MatchRoute", "nearestMatch", "nearestMatchRouteId", "matchRouteId", "strict", "matchSelection", "useMatches", "contextMatches", "findIndex", "Route", "getParentRoute", "customId", "addChildren", "update", "__onInit", "rootRouteWithContext", "RootRoute", "createRouteMask", "FileRoute", "createRoute", "lazyRouteComponent", "importer", "exportName", "lazyComp", "lazy", "moduleExports", "default", "useLinkProps", "activeProps", "className", "inactiveProps", "onFocus", "onMouseEnter", "onMouseLeave", "onTouchStart", "linkInfo", "composeHandlers", "handlers", "persist", "handler", "resolvedActiveProps", "resolvedInactiveProps", "role", "Link", "forwardRef", "linkProps", "_extends", "windowKey", "delimiter", "weakScrolledElements", "WeakSet", "cache", "sessionsStorage", "sessionStorage", "defaultGetKey", "useScrollRestoration", "getKey", "storageKey", "getItem", "cached", "set", "setItem", "scrollRestoration", "onScroll", "event", "has", "elementSelector", "getCssSelector", "c", "scrollX", "NaN", "scrollY", "el", "parentNode", "tagName", "indexOf", "addEventListener", "unsubOnBeforeLoad", "restoreKey", "entry", "element", "querySelector", "scrollLeft", "scrollTop", "unsubOnResolved", "windowRestored", "cacheKey", "scrollTo", "removeEventListener", "ScrollRestoration", "useBlocker", "condition", "unblock", "block", "retry", "cancel", "confirm", "Block", "useNavigate", "defaultOpts", "typedNavigate", "Navigate"]
}
